#pragma once

enum class STATE {
    NONE,
    NONE_V,
    NONE_VA,
    NONE_VAR,
    NONE_C,
    NONE_CO,
    NONE_CON,
    NONE_CONS,
    NONE_CONST,
    NONE_L,
    NONE_LE,
    NONE_LET,
    NONE_F,
    NONE_FU,
    NONE_FUN,
    NONE_FUNC,
    NONE_FUNCT,
    NONE_FUNCTI,
    NONE_FUNCTIO,
    NONE_FUNCTION,
    EXPECT_IDENTIFIER,
    IDENTIFIER_NAME,
    IDENTIFIER_COMPLETE,
    EXPECT_TYPE_ANNOTATION,
    TYPE_ANNOTATION,
    EXPECT_EQUALS,
    EXPRESSION_EXPECT_OPERAND,
    EXPRESSION_AFTER_OPERAND,
    EXPRESSION_AFTER_OPERAND_NEW_LINE,
    EXPRESSION_NUMBER,
    EXPRESSION_IDENTIFIER,
    EXPRESSION_SINGLE_QUOTE,
    EXPRESSION_SINGLE_QUOTE_ESCAPE,
    EXPRESSION_DOUBLE_QUOTE,
    EXPRESSION_DOUBLE_QUOTE_ESCAPE,
    EXPRESSION_PLUS,
    EXPRESSION_MINUS,
    EXPRESSION_LESS,
    EXPRESSION_GREATER,
    EXPRESSION_EQUALS,
    EXPRESSION_EQUALS_DOUBLE,
    EXPRESSION_NOT,
    EXPRESSION_NOT_EQUALS,
    EXPRESSION_AND,
    EXPRESSION_OR,
    EXPECT_IMMEDIATE_IDENTIFIER,
    VARIABLE_CREATE_IDENTIFIER_COMPLETE,
    FUNCTION_DECLARATION_NAME,
    FUNCTION_PARAMETERS_START,
    FUNCTION_PARAMETER_NAME,
    FUNCTION_PARAMETER_TYPE_ANNOTATION,
    FUNCTION_PARAMETER_DEFAULT_VALUE,
    FUNCTION_PARAMETER_SEPARATOR,
    FUNCTION_PARAMETERS_END,
    FUNCTION_RETURN_TYPE_ANNOTATION,
    FUNCTION_BODY_START,
    FUNCTION_BODY,
    ARROW_FUNCTION_PARAMETERS,
    ARROW_FUNCTION_ARROW,
    ARROW_FUNCTION_BODY,
    ARRAY_LITERAL_START,
    ARRAY_LITERAL_ELEMENT,
    ARRAY_LITERAL_SEPARATOR,
    OBJECT_LITERAL_START,
    OBJECT_LITERAL_PROPERTY_KEY,
    OBJECT_LITERAL_PROPERTY_COLON,
    OBJECT_LITERAL_PROPERTY_VALUE,
    OBJECT_LITERAL_SEPARATOR,
    IF_CONDITION_START,
    IF_CONSEQUENT,
    IF_ALTERNATE_START,
    IF_ALTERNATE,
    NONE_W,
    NONE_WH,
    NONE_WHI,
    NONE_WHIL,
    NONE_WHILE,
    WHILE_CONDITION_START,
    WHILE_BODY,
    // New states for missing TypeScript features
    EXPRESSION_PLUS_PLUS,
    EXPRESSION_MINUS_MINUS,
    EXPRESSION_LOGICAL_NOT,
    EXPRESSION_UNARY_PLUS,
    EXPRESSION_UNARY_MINUS,
    EXPRESSION_BITWISE_NOT,
    EXPRESSION_EXPONENT,
    EXPRESSION_BIT_AND,
    EXPRESSION_BIT_OR,
    EXPRESSION_BIT_XOR,
    EXPRESSION_LEFT_SHIFT,
    EXPRESSION_RIGHT_SHIFT,
    EXPRESSION_UNSIGNED_RIGHT_SHIFT,
    EXPRESSION_ADD_ASSIGN,
    EXPRESSION_SUBTRACT_ASSIGN,
    EXPRESSION_MULTIPLY_ASSIGN,
    EXPRESSION_DIVIDE_ASSIGN,
    EXPRESSION_MODULO_ASSIGN,
    EXPRESSION_EXPONENT_ASSIGN,
    EXPRESSION_LEFT_SHIFT_ASSIGN,
    EXPRESSION_RIGHT_SHIFT_ASSIGN,
    EXPRESSION_UNSIGNED_RIGHT_SHIFT_ASSIGN,
    EXPRESSION_BIT_AND_ASSIGN,
    EXPRESSION_BIT_OR_ASSIGN,
    EXPRESSION_BIT_XOR_ASSIGN,
    EXPRESSION_AND_ASSIGN,
    EXPRESSION_OR_ASSIGN,
    EXPRESSION_NULLISH_ASSIGN,
    EXPRESSION_TEMPLATE_LITERAL_START,
    EXPRESSION_TEMPLATE_LITERAL,
    EXPRESSION_TEMPLATE_LITERAL_ESCAPE,
    EXPRESSION_TEMPLATE_LITERAL_INTERPOLATION,
    EXPRESSION_REGEXP_START,
    EXPRESSION_REGEXP,
    EXPRESSION_REGEXP_ESCAPE,
    EXPRESSION_REGEXP_FLAGS,
    NONE_D,
    NONE_DO,
    NONE_DOW,
    NONE_DOWH,
    NONE_DOWHI,
    NONE_DOWHIL,
    NONE_DOWHILE,
    DO_BODY_START,
    DO_BODY,
    DO_WHILE_CONDITION_START,
    NONE_FO,
    NONE_FOR,
    FOR_INIT_START,
    FOR_INIT,
    FOR_TEST_START,
    FOR_TEST,
    FOR_UPDATE_START,
    FOR_UPDATE,
    FOR_BODY_START,
    FOR_BODY,
    NONE_S,
    NONE_SW,
    NONE_SWI,
    NONE_SWIT,
    NONE_SWITC,
    NONE_SWITCH,
    SWITCH_CONDITION_START,
    SWITCH_BODY_START,
    SWITCH_BODY,
    SWITCH_CASE_START,
    SWITCH_CASE,
    SWITCH_DEFAULT_START,
    SWITCH_DEFAULT,
    NONE_E,
    NONE_EL,
    NONE_ELS,
    NONE_ELSE,
    NONE_T,
    NONE_TR,
    NONE_TRY,
    TRY_BODY_START,
    TRY_BODY,
    TRY_CATCH_START,
    TRY_CATCH,
    TRY_CATCH_PARAM_START,
    TRY_CATCH_PARAM,
    TRY_CATCH_BODY_START,
    TRY_CATCH_BODY,
    TRY_FINALLY_START,
    TRY_FINALLY,
    TRY_FINALLY_BODY_START,
    TRY_FINALLY_BODY,
    FUNCTION_EXPRESSION_START,
    FUNCTION_EXPRESSION_PARAMETERS_START,
    FUNCTION_EXPRESSION_PARAMETER_NAME,
    FUNCTION_EXPRESSION_PARAMETER_TYPE_ANNOTATION,
    FUNCTION_EXPRESSION_PARAMETER_DEFAULT_VALUE,
    FUNCTION_EXPRESSION_PARAMETER_SEPARATOR,
    FUNCTION_EXPRESSION_PARAMETERS_END,
    FUNCTION_EXPRESSION_RETURN_TYPE_ANNOTATION,
    FUNCTION_EXPRESSION_BODY_START,
    FUNCTION_EXPRESSION_BODY,
    NONE_I,
    NONE_IN,
    NONE_INT,
    NONE_INTE,
    NONE_INTER,
    NONE_INTERF,
    NONE_INTERFA,
    NONE_INTERFAC,
    NONE_INTERFACE,
    INTERFACE_DECLARATION_NAME,
    INTERFACE_BODY_START,
    INTERFACE_BODY,
    INTERFACE_PROPERTY_KEY,
    INTERFACE_PROPERTY_TYPE,
    INTERFACE_METHOD_PARAMETERS_START,
    INTERFACE_METHOD_PARAMETERS_END,
    INTERFACE_METHOD_RETURN_TYPE,
    NONE_CL,
    NONE_CLA,
    NONE_CLAS,
    NONE_CLASS,
    CLASS_DECLARATION_NAME,
    CLASS_EXTENDS_START,
    CLASS_BODY_START,
    CLASS_BODY,
    CLASS_STATIC_START,
    CLASS_PROPERTY_KEY,
    CLASS_PROPERTY_TYPE,
    CLASS_PROPERTY_INITIALIZER,
    CLASS_METHOD_PARAMETERS_START,
    CLASS_METHOD_PARAMETERS_END,
    CLASS_METHOD_RETURN_TYPE,
    CLASS_METHOD_BODY_START,
    CLASS_METHOD_BODY,
    // Generic type states
    TYPE_GENERIC_PARAMETERS_START,
    TYPE_GENERIC_PARAMETER_NAME,
    TYPE_GENERIC_PARAMETER_SEPARATOR,
    TYPE_GENERIC_PARAMETERS_END,
    TYPE_GENERIC_TYPE_START,
    TYPE_GENERIC_TYPE_ARGUMENTS
};

inline const char* stateToString(STATE state) {
    switch (state) {
        case STATE::NONE: return "NONE";
        case STATE::NONE_V: return "V";
        case STATE::NONE_VA: return "VA";
        case STATE::NONE_VAR: return "VAR";
        case STATE::NONE_C: return "C";
        case STATE::NONE_CO: return "CO";
        case STATE::NONE_CON: return "CON";
        case STATE::NONE_CONS: return "CONS";
        case STATE::NONE_CONST: return "CONST";
        case STATE::NONE_L: return "L";
        case STATE::NONE_LE: return "LE";
        case STATE::NONE_LET: return "LET";
        case STATE::EXPECT_IDENTIFIER: return "AWAIT_IDENTIFIER";
        case STATE::IDENTIFIER_NAME: return "IDENTIFIER_NAME";
        case STATE::IDENTIFIER_COMPLETE: return "IDENTIFIER_COMPLETE";
        case STATE::EXPECT_TYPE_ANNOTATION: return "AWAIT_TYPE_ANNOTATION";
        case STATE::TYPE_ANNOTATION: return "TYPE_ANNOTATION";
        case STATE::EXPECT_EQUALS: return "AWAIT_EQUALS";
        case STATE::EXPRESSION_EXPECT_OPERAND: return "EXPRESSION_EXPECT_OPERAND";
        case STATE::EXPRESSION_AFTER_OPERAND: return "EXPRESSION_AFTER_OPERAND";
        case STATE::EXPRESSION_AFTER_OPERAND_NEW_LINE: return "EXPRESSION_AFTER_OPERAND_NEW_LINE";
        case STATE::EXPRESSION_NUMBER: return "EXPRESSION_NUMBER";
        case STATE::EXPRESSION_IDENTIFIER: return "EXPRESSION_IDENTIFIER";
        case STATE::EXPRESSION_SINGLE_QUOTE: return "EXPRESSION_SINGLE_QUOTE";
        case STATE::EXPRESSION_SINGLE_QUOTE_ESCAPE: return "EXPRESSION_SINGLE_QUOTE_ESCAPE";
        case STATE::EXPRESSION_DOUBLE_QUOTE: return "EXPRESSION_DOUBLE_QUOTE";
        case STATE::EXPRESSION_DOUBLE_QUOTE_ESCAPE: return "EXPRESSION_DOUBLE_QUOTE_ESCAPE";
        case STATE::EXPRESSION_PLUS: return "EXPRESSION_PLUS";
        case STATE::EXPRESSION_MINUS: return "EXPRESSION_MINUS";
        case STATE::EXPRESSION_LESS: return "EXPRESSION_LESS";
        case STATE::EXPRESSION_GREATER: return "EXPRESSION_GREATER";
        case STATE::EXPRESSION_EQUALS: return "EXPRESSION_EQUALS";
        case STATE::EXPRESSION_EQUALS_DOUBLE: return "EXPRESSION_EQUALS_DOUBLE";
        case STATE::EXPRESSION_NOT: return "EXPRESSION_NOT";
        case STATE::EXPRESSION_NOT_EQUALS: return "EXPRESSION_NOT_EQUALS";
        case STATE::EXPRESSION_AND: return "EXPRESSION_AND";
        case STATE::EXPRESSION_OR: return "EXPRESSION_OR";
        case STATE::EXPECT_IMMEDIATE_IDENTIFIER: return "EXPECT_IMMEDIATE_IDENTIFIER";
        case STATE::VARIABLE_CREATE_IDENTIFIER_COMPLETE: return "VARIABLE_CREATE_IDENTIFIER_COMPLETE";
        case STATE::NONE_F: return "F";
        case STATE::NONE_FU: return "FU";
        case STATE::NONE_FUN: return "FUN";
        case STATE::NONE_FUNC: return "FUNC";
        case STATE::NONE_FUNCT: return "FUNCT";
        case STATE::NONE_FUNCTI: return "FUNCTI";
        case STATE::NONE_FUNCTIO: return "FUNCTIO";
        case STATE::NONE_FUNCTION: return "FUNCTION";
        case STATE::FUNCTION_DECLARATION_NAME: return "FUNCTION_DECLARATION_NAME";
        case STATE::FUNCTION_PARAMETERS_START: return "FUNCTION_PARAMETERS_START";
        case STATE::FUNCTION_PARAMETER_NAME: return "FUNCTION_PARAMETER_NAME";
        case STATE::FUNCTION_PARAMETER_TYPE_ANNOTATION: return "FUNCTION_PARAMETER_TYPE_ANNOTATION";
        case STATE::FUNCTION_PARAMETER_DEFAULT_VALUE: return "FUNCTION_PARAMETER_DEFAULT_VALUE";
        case STATE::FUNCTION_PARAMETER_SEPARATOR: return "FUNCTION_PARAMETER_SEPARATOR";
        case STATE::FUNCTION_PARAMETERS_END: return "FUNCTION_PARAMETERS_END";
        case STATE::FUNCTION_RETURN_TYPE_ANNOTATION: return "FUNCTION_RETURN_TYPE_ANNOTATION";
        case STATE::FUNCTION_BODY_START: return "FUNCTION_BODY_START";
        case STATE::FUNCTION_BODY: return "FUNCTION_BODY";
        case STATE::ARROW_FUNCTION_PARAMETERS: return "ARROW_FUNCTION_PARAMETERS";
        case STATE::ARROW_FUNCTION_ARROW: return "ARROW_FUNCTION_ARROW";
        case STATE::ARROW_FUNCTION_BODY: return "ARROW_FUNCTION_BODY";
        case STATE::ARRAY_LITERAL_START: return "ARRAY_LITERAL_START";
        case STATE::ARRAY_LITERAL_ELEMENT: return "ARRAY_LITERAL_ELEMENT";
        case STATE::ARRAY_LITERAL_SEPARATOR: return "ARRAY_LITERAL_SEPARATOR";
        case STATE::OBJECT_LITERAL_START: return "OBJECT_LITERAL_START";
        case STATE::OBJECT_LITERAL_PROPERTY_KEY: return "OBJECT_LITERAL_PROPERTY_KEY";
        case STATE::OBJECT_LITERAL_PROPERTY_COLON: return "OBJECT_LITERAL_PROPERTY_COLON";
        case STATE::OBJECT_LITERAL_PROPERTY_VALUE: return "OBJECT_LITERAL_PROPERTY_VALUE";
        case STATE::OBJECT_LITERAL_SEPARATOR: return "OBJECT_LITERAL_SEPARATOR";
        case STATE::IF_CONDITION_START: return "IF_CONDITION_START";
        case STATE::IF_CONSEQUENT: return "IF_CONSEQUENT";
        case STATE::IF_ALTERNATE_START: return "IF_ALTERNATE_START";
        case STATE::IF_ALTERNATE: return "IF_ALTERNATE";
        case STATE::NONE_W: return "W";
        case STATE::NONE_WH: return "WH";
        case STATE::NONE_WHI: return "WHI";
        case STATE::NONE_WHIL: return "WHIL";
        case STATE::NONE_WHILE: return "WHILE";
        case STATE::WHILE_CONDITION_START: return "WHILE_CONDITION_START";
        case STATE::WHILE_BODY: return "WHILE_BODY";
        // New states for missing TypeScript features
        case STATE::EXPRESSION_PLUS_PLUS: return "EXPRESSION_PLUS_PLUS";
        case STATE::EXPRESSION_MINUS_MINUS: return "EXPRESSION_MINUS_MINUS";
        case STATE::EXPRESSION_LOGICAL_NOT: return "EXPRESSION_LOGICAL_NOT";
        case STATE::EXPRESSION_UNARY_PLUS: return "EXPRESSION_UNARY_PLUS";
        case STATE::EXPRESSION_UNARY_MINUS: return "EXPRESSION_UNARY_MINUS";
        case STATE::EXPRESSION_BITWISE_NOT: return "EXPRESSION_BITWISE_NOT";
        case STATE::EXPRESSION_EXPONENT: return "EXPRESSION_EXPONENT";
        case STATE::EXPRESSION_BIT_AND: return "EXPRESSION_BIT_AND";
        case STATE::EXPRESSION_BIT_OR: return "EXPRESSION_BIT_OR";
        case STATE::EXPRESSION_BIT_XOR: return "EXPRESSION_BIT_XOR";
        case STATE::EXPRESSION_LEFT_SHIFT: return "EXPRESSION_LEFT_SHIFT";
        case STATE::EXPRESSION_RIGHT_SHIFT: return "EXPRESSION_RIGHT_SHIFT";
        case STATE::EXPRESSION_UNSIGNED_RIGHT_SHIFT: return "EXPRESSION_UNSIGNED_RIGHT_SHIFT";
        case STATE::EXPRESSION_ADD_ASSIGN: return "EXPRESSION_ADD_ASSIGN";
        case STATE::EXPRESSION_SUBTRACT_ASSIGN: return "EXPRESSION_SUBTRACT_ASSIGN";
        case STATE::EXPRESSION_MULTIPLY_ASSIGN: return "EXPRESSION_MULTIPLY_ASSIGN";
        case STATE::EXPRESSION_DIVIDE_ASSIGN: return "EXPRESSION_DIVIDE_ASSIGN";
        case STATE::EXPRESSION_MODULO_ASSIGN: return "EXPRESSION_MODULO_ASSIGN";
        case STATE::EXPRESSION_EXPONENT_ASSIGN: return "EXPRESSION_EXPONENT_ASSIGN";
        case STATE::EXPRESSION_LEFT_SHIFT_ASSIGN: return "EXPRESSION_LEFT_SHIFT_ASSIGN";
        case STATE::EXPRESSION_RIGHT_SHIFT_ASSIGN: return "EXPRESSION_RIGHT_SHIFT_ASSIGN";
        case STATE::EXPRESSION_UNSIGNED_RIGHT_SHIFT_ASSIGN: return "EXPRESSION_UNSIGNED_RIGHT_SHIFT_ASSIGN";
        case STATE::EXPRESSION_BIT_AND_ASSIGN: return "EXPRESSION_BIT_AND_ASSIGN";
        case STATE::EXPRESSION_BIT_OR_ASSIGN: return "EXPRESSION_BIT_OR_ASSIGN";
        case STATE::EXPRESSION_BIT_XOR_ASSIGN: return "EXPRESSION_BIT_XOR_ASSIGN";
        case STATE::EXPRESSION_AND_ASSIGN: return "EXPRESSION_AND_ASSIGN";
        case STATE::EXPRESSION_OR_ASSIGN: return "EXPRESSION_OR_ASSIGN";
        case STATE::EXPRESSION_NULLISH_ASSIGN: return "EXPRESSION_NULLISH_ASSIGN";
        case STATE::EXPRESSION_TEMPLATE_LITERAL_START: return "EXPRESSION_TEMPLATE_LITERAL_START";
        case STATE::EXPRESSION_TEMPLATE_LITERAL: return "EXPRESSION_TEMPLATE_LITERAL";
        case STATE::EXPRESSION_TEMPLATE_LITERAL_ESCAPE: return "EXPRESSION_TEMPLATE_LITERAL_ESCAPE";
        case STATE::EXPRESSION_TEMPLATE_LITERAL_INTERPOLATION: return "EXPRESSION_TEMPLATE_LITERAL_INTERPOLATION";
        case STATE::EXPRESSION_REGEXP_START: return "EXPRESSION_REGEXP_START";
        case STATE::EXPRESSION_REGEXP: return "EXPRESSION_REGEXP";
        case STATE::EXPRESSION_REGEXP_ESCAPE: return "EXPRESSION_REGEXP_ESCAPE";
        case STATE::EXPRESSION_REGEXP_FLAGS: return "EXPRESSION_REGEXP_FLAGS";
        case STATE::NONE_D: return "D";
        case STATE::NONE_DO: return "DO";
        case STATE::NONE_DOW: return "DOW";
        case STATE::NONE_DOWH: return "DOWH";
        case STATE::NONE_DOWHI: return "DOWHI";
        case STATE::NONE_DOWHIL: return "DOWHIL";
        case STATE::NONE_DOWHILE: return "DOWHILE";
        case STATE::DO_BODY_START: return "DO_BODY_START";
        case STATE::DO_BODY: return "DO_BODY";
        case STATE::DO_WHILE_CONDITION_START: return "DO_WHILE_CONDITION_START";
        case STATE::NONE_FO: return "FO";
        case STATE::NONE_FOR: return "FOR";
        case STATE::FOR_INIT_START: return "FOR_INIT_START";
        case STATE::FOR_INIT: return "FOR_INIT";
        case STATE::FOR_TEST_START: return "FOR_TEST_START";
        case STATE::FOR_TEST: return "FOR_TEST";
        case STATE::FOR_UPDATE_START: return "FOR_UPDATE_START";
        case STATE::FOR_UPDATE: return "FOR_UPDATE";
        case STATE::FOR_BODY_START: return "FOR_BODY_START";
        case STATE::FOR_BODY: return "FOR_BODY";
        case STATE::NONE_S: return "S";
        case STATE::NONE_SW: return "SW";
        case STATE::NONE_SWI: return "SWI";
        case STATE::NONE_SWIT: return "SWIT";
        case STATE::NONE_SWITC: return "SWITC";
        case STATE::NONE_SWITCH: return "SWITCH";
        case STATE::SWITCH_CONDITION_START: return "SWITCH_CONDITION_START";
        case STATE::SWITCH_BODY_START: return "SWITCH_BODY_START";
        case STATE::SWITCH_BODY: return "SWITCH_BODY";
        case STATE::SWITCH_CASE_START: return "SWITCH_CASE_START";
        case STATE::SWITCH_CASE: return "SWITCH_CASE";
        case STATE::SWITCH_DEFAULT_START: return "SWITCH_DEFAULT_START";
        case STATE::SWITCH_DEFAULT: return "SWITCH_DEFAULT";
        case STATE::NONE_E: return "E";
        case STATE::NONE_EL: return "EL";
        case STATE::NONE_ELS: return "ELS";
        case STATE::NONE_ELSE: return "ELSE";
        case STATE::NONE_T: return "T";
        case STATE::NONE_TR: return "TR";
        case STATE::NONE_TRY: return "TRY";
        case STATE::TRY_BODY_START: return "TRY_BODY_START";
        case STATE::TRY_BODY: return "TRY_BODY";
        case STATE::TRY_CATCH_START: return "TRY_CATCH_START";
        case STATE::TRY_CATCH: return "TRY_CATCH";
        case STATE::TRY_CATCH_PARAM_START: return "TRY_CATCH_PARAM_START";
        case STATE::TRY_CATCH_PARAM: return "TRY_CATCH_PARAM";
        case STATE::TRY_CATCH_BODY_START: return "TRY_CATCH_BODY_START";
        case STATE::TRY_CATCH_BODY: return "TRY_CATCH_BODY";
        case STATE::TRY_FINALLY_START: return "TRY_FINALLY_START";
        case STATE::TRY_FINALLY: return "TRY_FINALLY";
        case STATE::TRY_FINALLY_BODY_START: return "TRY_FINALLY_BODY_START";
        case STATE::TRY_FINALLY_BODY: return "TRY_FINALLY_BODY";
        case STATE::FUNCTION_EXPRESSION_START: return "FUNCTION_EXPRESSION_START";
        case STATE::FUNCTION_EXPRESSION_PARAMETERS_START: return "FUNCTION_EXPRESSION_PARAMETERS_START";
        case STATE::FUNCTION_EXPRESSION_PARAMETER_NAME: return "FUNCTION_EXPRESSION_PARAMETER_NAME";
        case STATE::FUNCTION_EXPRESSION_PARAMETER_TYPE_ANNOTATION: return "FUNCTION_EXPRESSION_PARAMETER_TYPE_ANNOTATION";
        case STATE::FUNCTION_EXPRESSION_PARAMETER_DEFAULT_VALUE: return "FUNCTION_EXPRESSION_PARAMETER_DEFAULT_VALUE";
        case STATE::FUNCTION_EXPRESSION_PARAMETER_SEPARATOR: return "FUNCTION_EXPRESSION_PARAMETER_SEPARATOR";
        case STATE::FUNCTION_EXPRESSION_PARAMETERS_END: return "FUNCTION_EXPRESSION_PARAMETERS_END";
        case STATE::FUNCTION_EXPRESSION_RETURN_TYPE_ANNOTATION: return "FUNCTION_EXPRESSION_RETURN_TYPE_ANNOTATION";
        case STATE::FUNCTION_EXPRESSION_BODY_START: return "FUNCTION_EXPRESSION_BODY_START";
        case STATE::FUNCTION_EXPRESSION_BODY: return "FUNCTION_EXPRESSION_BODY";
        case STATE::NONE_I: return "I";
        case STATE::NONE_IN: return "IN";
        case STATE::NONE_INT: return "INT";
        case STATE::NONE_INTE: return "INTE";
        case STATE::NONE_INTER: return "INTER";
        case STATE::NONE_INTERF: return "INTERF";
        case STATE::NONE_INTERFA: return "INTERFA";
        case STATE::NONE_INTERFAC: return "INTERFAC";
        case STATE::NONE_INTERFACE: return "INTERFACE";
        case STATE::INTERFACE_DECLARATION_NAME: return "INTERFACE_DECLARATION_NAME";
        case STATE::INTERFACE_BODY_START: return "INTERFACE_BODY_START";
        case STATE::INTERFACE_BODY: return "INTERFACE_BODY";
        case STATE::INTERFACE_PROPERTY_KEY: return "INTERFACE_PROPERTY_KEY";
        case STATE::INTERFACE_PROPERTY_TYPE: return "INTERFACE_PROPERTY_TYPE";
        case STATE::INTERFACE_METHOD_PARAMETERS_START: return "INTERFACE_METHOD_PARAMETERS_START";
        case STATE::INTERFACE_METHOD_PARAMETERS_END: return "INTERFACE_METHOD_PARAMETERS_END";
        case STATE::INTERFACE_METHOD_RETURN_TYPE: return "INTERFACE_METHOD_RETURN_TYPE";
        case STATE::NONE_CL: return "CL";
        case STATE::NONE_CLA: return "CLA";
        case STATE::NONE_CLAS: return "CLAS";
        case STATE::NONE_CLASS: return "CLASS";
        case STATE::CLASS_DECLARATION_NAME: return "CLASS_DECLARATION_NAME";
        case STATE::CLASS_EXTENDS_START: return "CLASS_EXTENDS_START";
        case STATE::CLASS_BODY_START: return "CLASS_BODY_START";
        case STATE::CLASS_BODY: return "CLASS_BODY";
        case STATE::CLASS_STATIC_START: return "CLASS_STATIC_START";
        case STATE::CLASS_PROPERTY_KEY: return "CLASS_PROPERTY_KEY";
        case STATE::CLASS_PROPERTY_TYPE: return "CLASS_PROPERTY_TYPE";
        case STATE::CLASS_PROPERTY_INITIALIZER: return "CLASS_PROPERTY_INITIALIZER";
        case STATE::CLASS_METHOD_PARAMETERS_START: return "CLASS_METHOD_PARAMETERS_START";
        case STATE::CLASS_METHOD_PARAMETERS_END: return "CLASS_METHOD_PARAMETERS_END";
        case STATE::CLASS_METHOD_RETURN_TYPE: return "CLASS_METHOD_RETURN_TYPE";
        case STATE::CLASS_METHOD_BODY_START: return "CLASS_METHOD_BODY_START";
        case STATE::CLASS_METHOD_BODY: return "CLASS_METHOD_BODY";
        // Generic type states
        case STATE::TYPE_GENERIC_PARAMETERS_START: return "TYPE_GENERIC_PARAMETERS_START";
        case STATE::TYPE_GENERIC_PARAMETER_NAME: return "TYPE_GENERIC_PARAMETER_NAME";
        case STATE::TYPE_GENERIC_PARAMETER_SEPARATOR: return "TYPE_GENERIC_PARAMETER_SEPARATOR";
        case STATE::TYPE_GENERIC_PARAMETERS_END: return "TYPE_GENERIC_PARAMETERS_END";
        case STATE::TYPE_GENERIC_TYPE_START: return "TYPE_GENERIC_TYPE_START";
        case STATE::TYPE_GENERIC_TYPE_ARGUMENTS: return "TYPE_GENERIC_TYPE_ARGUMENTS";
    }
    return "UNKNOWN_STATE";
}
